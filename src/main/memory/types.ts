/**
 * Atlas Desktop - Memory System Types
 * Type definitions for conversation summarization and memory management
 */

/**
 * Summary level for hierarchical summarization
 */
export type SummaryLevel = 'conversation' | 'session' | 'daily' | 'weekly' | 'monthly';

/**
 * Conversation summary generated by LLM
 */
export interface ConversationSummary {
  /** Unique summary ID */
  id: string;
  /** Session ID this summary belongs to */
  sessionId: string;
  /** Level of summarization */
  level: SummaryLevel;
  /** Generated summary text */
  summary: string;
  /** Key facts extracted from conversation */
  keyFacts: string[];
  /** Decisions made during conversation */
  decisions: string[];
  /** Action items identified */
  actionItems: ActionItem[];
  /** Main topics discussed */
  topics: string[];
  /** Overall sentiment of the conversation */
  sentiment: 'positive' | 'negative' | 'neutral' | 'mixed';
  /** Number of exchanges summarized */
  exchangeCount: number;
  /** Start timestamp of summarized content */
  startTime: number;
  /** End timestamp of summarized content */
  endTime: number;
  /** Creation timestamp of this summary */
  createdAt: number;
  /** IDs of child summaries (for hierarchical) */
  childSummaryIds?: string[];
  /** Parent summary ID (for hierarchical) */
  parentSummaryId?: string;
  /** Token count of original content */
  originalTokens: number;
  /** Token count of summary */
  summaryTokens: number;
  /** Compression ratio achieved */
  compressionRatio: number;
  /** Metadata for filtering and search */
  metadata?: Record<string, unknown>;
}

/**
 * Action item extracted from conversation
 */
export interface ActionItem {
  /** Action item description */
  description: string;
  /** Priority level */
  priority: 'high' | 'medium' | 'low';
  /** Due date if mentioned */
  dueDate?: number;
  /** Assignee if mentioned (usually 'user' or 'atlas') */
  assignee?: string;
  /** Completion status */
  completed: boolean;
  /** Source exchange ID */
  sourceExchangeId?: string;
}

/**
 * Exchange (user message + assistant response pair)
 */
export interface ConversationExchange {
  /** Exchange ID */
  id: string;
  /** User message content */
  userMessage: string;
  /** Assistant response content */
  assistantResponse: string;
  /** Exchange timestamp */
  timestamp: number;
  /** Extracted topics */
  topics?: string[];
  /** Sentiment of this exchange */
  sentiment?: 'positive' | 'negative' | 'neutral';
  /** Importance score (0-1) */
  importance?: number;
}

/**
 * Summarization configuration
 */
export interface SummarizationConfig {
  /** Minimum exchanges before auto-summarization */
  minExchangesForSummary: number;
  /** Maximum exchanges before forced summarization */
  maxExchangesBeforeSummary: number;
  /** Target summary length in tokens */
  targetSummaryTokens: number;
  /** Enable automatic summarization */
  enableAutoSummarization: boolean;
  /** Summarize on session end */
  summarizeOnSessionEnd: boolean;
  /** Enable hierarchical summarization */
  enableHierarchicalSummary: boolean;
  /** Daily summary hour (0-23, -1 to disable) */
  dailySummaryHour: number;
  /** Weekly summary day (0=Sunday, 6=Saturday, -1 to disable) */
  weeklySummaryDay: number;
  /** Monthly summary day (1-28, -1 to disable) */
  monthlySummaryDay: number;
  /** Model to use for summarization (optional override) */
  summaryModel?: string;
  /** Maximum tokens for summarization context */
  maxContextTokens: number;
  /** Enable fact extraction */
  extractFacts: boolean;
  /** Enable decision extraction */
  extractDecisions: boolean;
  /** Enable action item extraction */
  extractActionItems: boolean;
}

/**
 * Default summarization configuration
 */
export const DEFAULT_SUMMARIZATION_CONFIG: SummarizationConfig = {
  minExchangesForSummary: 5,
  maxExchangesBeforeSummary: 20,
  targetSummaryTokens: 300,
  enableAutoSummarization: true,
  summarizeOnSessionEnd: true,
  enableHierarchicalSummary: true,
  dailySummaryHour: 23, // 11 PM
  weeklySummaryDay: 0, // Sunday
  monthlySummaryDay: 1, // First of month
  maxContextTokens: 8000,
  extractFacts: true,
  extractDecisions: true,
  extractActionItems: true,
};

/**
 * Summary search options
 */
export interface SummarySearchOptions {
  /** Search query text */
  query?: string;
  /** Filter by summary level */
  level?: SummaryLevel;
  /** Filter by session ID */
  sessionId?: string;
  /** Filter by topics (any match) */
  topics?: string[];
  /** Filter by start date */
  startDate?: number;
  /** Filter by end date */
  endDate?: number;
  /** Filter by sentiment */
  sentiment?: ConversationSummary['sentiment'];
  /** Include action items only */
  hasActionItems?: boolean;
  /** Maximum results */
  limit?: number;
  /** Skip N results for pagination */
  offset?: number;
  /** Sort by field */
  sortBy?: 'createdAt' | 'startTime' | 'exchangeCount' | 'compressionRatio';
  /** Sort direction */
  sortOrder?: 'asc' | 'desc';
}

/**
 * Summary search result
 */
export interface SummarySearchResult {
  /** Matching summaries */
  summaries: ConversationSummary[];
  /** Total matching count (before pagination) */
  totalCount: number;
  /** Search query used */
  query?: string;
  /** Time taken for search (ms) */
  searchTimeMs: number;
}

/**
 * Summarization result from a summarization operation
 */
export interface SummarizationResult {
  /** Generated summary */
  summary: ConversationSummary;
  /** Number of exchanges processed */
  exchangesProcessed: number;
  /** Time taken for summarization (ms) */
  processingTimeMs: number;
  /** Whether summarization used LLM */
  usedLLM: boolean;
  /** Error if summarization partially failed */
  error?: string;
}

/**
 * Hierarchical summary rollup result
 */
export interface HierarchicalRollupResult {
  /** Level being rolled up to */
  targetLevel: SummaryLevel;
  /** Summaries that were rolled up */
  sourceSummaryIds: string[];
  /** New summary created */
  newSummary: ConversationSummary;
  /** Processing time (ms) */
  processingTimeMs: number;
}

/**
 * Summarizer statistics
 */
export interface SummarizerStats {
  /** Total summaries created */
  totalSummaries: number;
  /** Summaries by level */
  summariesByLevel: Record<SummaryLevel, number>;
  /** Total exchanges summarized */
  totalExchangesSummarized: number;
  /** Total action items extracted */
  totalActionItems: number;
  /** Completed action items */
  completedActionItems: number;
  /** Average compression ratio */
  averageCompressionRatio: number;
  /** Total tokens saved */
  totalTokensSaved: number;
  /** Last summarization time */
  lastSummarizationTime?: number;
}

/**
 * Summarizer events
 */
export interface SummarizerEvents {
  /** Summarization started */
  'summarization-started': (level: SummaryLevel, exchangeCount: number) => void;
  /** Summarization completed */
  'summarization-completed': (result: SummarizationResult) => void;
  /** Hierarchical rollup completed */
  'rollup-completed': (result: HierarchicalRollupResult) => void;
  /** Action item extracted */
  'action-item-extracted': (item: ActionItem) => void;
  /** Summary search performed */
  'search-performed': (options: SummarySearchOptions, resultCount: number) => void;
  /** Error occurred */
  'error': (error: Error, context?: string) => void;
}

// ============================================================================
// Cross-Session Context Types
// ============================================================================

/**
 * Persisted session context for cross-session continuity
 */
export interface SessionContext {
  /** Unique context ID */
  id: string;
  /** Associated session ID */
  sessionId: string;
  /** Context creation timestamp */
  createdAt: number;
  /** Last updated timestamp */
  updatedAt: number;
  /** Context end timestamp (when session ended) */
  endedAt?: number;
  /** Main topics discussed in this session */
  topics: string[];
  /** Key facts learned during session */
  keyFacts: string[];
  /** User preferences expressed */
  preferences: UserPreference[];
  /** Unresolved questions or tasks */
  pendingItems: PendingItem[];
  /** Session summary for quick reference */
  summary: string;
  /** Relevance score (0-1, decays over time) */
  relevance: number;
  /** Number of exchanges in this session */
  exchangeCount: number;
  /** Links to related sessions (by topic similarity) */
  relatedSessionIds: string[];
  /** Metadata for filtering */
  metadata?: Record<string, unknown>;
}

/**
 * User preference extracted from conversations
 */
export interface UserPreference {
  /** Preference category */
  category: PreferenceCategory;
  /** Preference key (e.g., 'programming_language', 'communication_style') */
  key: string;
  /** Preference value */
  value: string;
  /** Confidence score (0-1) */
  confidence: number;
  /** When this preference was first detected */
  firstDetected: number;
  /** Last time this preference was confirmed */
  lastConfirmed: number;
  /** Number of times this preference was expressed */
  confirmationCount: number;
}

/**
 * Preference categories
 */
export type PreferenceCategory =
  | 'communication' // How user likes to communicate
  | 'technical' // Technical preferences (languages, tools)
  | 'workflow' // Work style preferences
  | 'schedule' // Time/schedule preferences
  | 'content' // Content format preferences
  | 'personal' // Personal information
  | 'other';

/**
 * Pending item from a session (unresolved task or question)
 */
export interface PendingItem {
  /** Item ID */
  id: string;
  /** Type of pending item */
  type: 'question' | 'task' | 'follow_up' | 'reminder';
  /** Description of the pending item */
  description: string;
  /** Priority level */
  priority: 'high' | 'medium' | 'low';
  /** When this item was created */
  createdAt: number;
  /** Whether this item has been resolved */
  resolved: boolean;
  /** When resolved */
  resolvedAt?: number;
  /** Context about how it was resolved */
  resolution?: string;
}

/**
 * Cross-session context configuration
 */
export interface SessionContextConfig {
  /** Storage directory for session contexts */
  storageDir: string;
  /** Maximum number of session contexts to retain */
  maxSessionContexts: number;
  /** Context relevance decay rate per day (0-1) */
  decayRatePerDay: number;
  /** Minimum relevance score before context is archived */
  minRelevanceThreshold: number;
  /** Maximum age in days before forced archival */
  maxContextAgeDays: number;
  /** Enable automatic context linking */
  enableContextLinking: boolean;
  /** Minimum topic overlap for context linking (0-1) */
  topicOverlapThreshold: number;
  /** Maximum related sessions to track */
  maxRelatedSessions: number;
  /** Auto-save interval in ms */
  autoSaveInterval: number;
  /** Generate welcome summary on new session */
  generateWelcomeSummary: boolean;
  /** Maximum items in welcome summary */
  welcomeSummaryMaxItems: number;
}

/**
 * Default session context configuration
 */
export const DEFAULT_SESSION_CONTEXT_CONFIG: SessionContextConfig = {
  storageDir: '', // Set dynamically based on platform
  maxSessionContexts: 50,
  decayRatePerDay: 0.05, // 5% decay per day
  minRelevanceThreshold: 0.1,
  maxContextAgeDays: 90,
  enableContextLinking: true,
  topicOverlapThreshold: 0.3,
  maxRelatedSessions: 5,
  autoSaveInterval: 60000, // 1 minute
  generateWelcomeSummary: true,
  welcomeSummaryMaxItems: 5,
};

/**
 * Welcome back summary for session continuity
 */
export interface WelcomeBackSummary {
  /** Whether there is relevant context to show */
  hasRelevantContext: boolean;
  /** Last session timestamp */
  lastSessionTime?: number;
  /** Time since last session in human-readable format */
  timeSinceLastSession?: string;
  /** Topics from previous sessions to potentially continue */
  continuableTopics: string[];
  /** Pending items that may need attention */
  pendingItems: PendingItem[];
  /** Key facts to remember about the user */
  relevantFacts: string[];
  /** Generated summary text for display */
  summaryText: string;
  /** Most relevant previous session */
  mostRelevantSession?: {
    sessionId: string;
    summary: string;
    topics: string[];
    timestamp: number;
  };
}

/**
 * Context retrieval options
 */
export interface ContextRetrievalOptions {
  /** Current conversation topics to match against */
  currentTopics?: string[];
  /** Current query/message for semantic matching */
  currentQuery?: string;
  /** Maximum number of contexts to retrieve */
  limit?: number;
  /** Minimum relevance score */
  minRelevance?: number;
  /** Time range filter - start */
  startTime?: number;
  /** Time range filter - end */
  endTime?: number;
  /** Include resolved pending items */
  includeResolved?: boolean;
  /** Specific session IDs to include */
  sessionIds?: string[];
}

/**
 * Context retrieval result
 */
export interface ContextRetrievalResult {
  /** Retrieved session contexts, sorted by relevance */
  contexts: SessionContext[];
  /** Aggregated topics across all retrieved contexts */
  aggregatedTopics: string[];
  /** Aggregated key facts */
  aggregatedFacts: string[];
  /** Unresolved pending items across contexts */
  pendingItems: PendingItem[];
  /** Active user preferences */
  preferences: UserPreference[];
  /** Total number of matching contexts */
  totalMatches: number;
  /** Search time in ms */
  searchTimeMs: number;
}

/**
 * Session context events
 */
export interface SessionContextEvents {
  /** New session context created */
  'context-created': (context: SessionContext) => void;
  /** Session context updated */
  'context-updated': (context: SessionContext) => void;
  /** Session context ended */
  'context-ended': (sessionId: string) => void;
  /** Context relevance decayed */
  'context-decayed': (sessionId: string, newRelevance: number) => void;
  /** Context archived (below threshold) */
  'context-archived': (sessionId: string) => void;
  /** Contexts linked */
  'contexts-linked': (sessionId1: string, sessionId2: string) => void;
  /** Welcome summary generated */
  'welcome-summary-generated': (summary: WelcomeBackSummary) => void;
  /** Context reset by user */
  'context-reset': () => void;
  /** Error occurred */
  error: (error: Error, context?: string) => void;
}

/**
 * LLM prompt templates for session context
 */
export const SESSION_CONTEXT_PROMPTS = {
  /** Generate welcome back summary */
  welcomeBackSummary: `Based on the following previous session summaries and context, generate a brief, friendly "welcome back" message.

Previous Sessions:
{sessions}

Pending Items:
{pendingItems}

User Preferences:
{preferences}

Generate a natural, conversational summary that:
1. Briefly mentions what was discussed last time (if relevant)
2. Notes any pending items that might need follow-up
3. Shows awareness of user preferences
4. Is warm but concise (2-3 sentences max)

Return as JSON:
{
  "summaryText": "The welcome back message",
  "shouldMentionTopics": ["topics worth continuing"],
  "shouldMentionPending": ["pending items to follow up"]
}`,

  /** Extract preferences from conversation */
  extractPreferences: `Analyze this conversation and extract any user preferences expressed.

Conversation:
{conversation}

Look for:
- Communication style preferences (formal/informal, detailed/brief)
- Technical preferences (programming languages, tools, platforms)
- Workflow preferences (how they like to work)
- Schedule preferences (time zones, availability)
- Content preferences (format preferences, examples vs theory)

Return as JSON array:
[
  {
    "category": "communication|technical|workflow|schedule|content|personal|other",
    "key": "preference key",
    "value": "preference value",
    "confidence": 0.0-1.0
  }
]

Only include clearly expressed preferences, not assumptions.`,

  /** Identify pending items */
  extractPendingItems: `Analyze this conversation and identify any unresolved items.

Conversation:
{conversation}

Look for:
- Questions that weren't fully answered
- Tasks mentioned but not completed
- Follow-up items discussed
- Reminders or promises made

Return as JSON array:
[
  {
    "type": "question|task|follow_up|reminder",
    "description": "clear description",
    "priority": "high|medium|low"
  }
]

Only include genuinely unresolved items.`,
};

/**
 * LLM prompt templates for summarization
 */
export const SUMMARIZATION_PROMPTS = {
  /** Main conversation summary prompt */
  conversationSummary: `Summarize the following conversation between a user and Atlas (an AI assistant).

Conversation:
{conversation}

Provide a JSON response with the following structure:
{
  "summary": "A concise summary of the main points discussed (2-3 sentences)",
  "keyFacts": ["Array of important facts mentioned"],
  "decisions": ["Array of decisions made during the conversation"],
  "actionItems": [{"description": "task description", "priority": "high|medium|low", "assignee": "user|atlas"}],
  "topics": ["Array of main topics discussed"],
  "sentiment": "positive|negative|neutral|mixed"
}

Focus on:
- Key information exchanged
- Any tasks or commitments made
- Important facts the user shared
- Overall tone of the conversation`,

  /** Hierarchical rollup prompt */
  hierarchicalRollup: `Consolidate the following {level} summaries into a single higher-level summary.

Previous summaries:
{summaries}

Provide a JSON response with the same structure, combining and condensing the information:
{
  "summary": "A consolidated summary covering all the summarized periods",
  "keyFacts": ["Combined key facts, removing duplicates"],
  "decisions": ["All significant decisions"],
  "actionItems": [{"description": "task", "priority": "high|medium|low", "completed": false}],
  "topics": ["Main recurring topics"],
  "sentiment": "overall sentiment"
}

Focus on patterns, recurring themes, and the most important information.`,

  /** Action item extraction prompt */
  extractActionItems: `Extract action items from this conversation:

{conversation}

Return a JSON array of action items:
[
  {
    "description": "Clear description of the task",
    "priority": "high|medium|low",
    "dueDate": null or ISO date string if mentioned,
    "assignee": "user|atlas|unknown"
  }
]

Only include clear, actionable tasks. Ignore vague suggestions.`,
};
