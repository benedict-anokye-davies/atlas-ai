/**
 * Atlas Desktop - Git PR (Pull Request) Tools
 *
 * Provides GitHub/GitLab pull request creation and management via voice commands.
 * Uses GitHub CLI (gh) for GitHub operations, with fallback patterns for other platforms.
 *
 * Voice commands supported:
 * - "Create pull request"
 * - "Open PR to main"
 * - "Create PR with title..."
 * - "Add reviewers to PR"
 *
 * @module agent/tools/git-pr
 */

import { spawn, SpawnOptions } from 'child_process';
import * as path from 'path';
import * as os from 'os';
import { AgentTool, ActionResult } from '../../../shared/types/agent';
import { createModuleLogger } from '../../utils/logger';
import { getLLMManager } from '../../llm/manager';
import { createConversationContext } from '../../../shared/types/llm';

const logger = createModuleLogger('GitPR');

// Configuration
const DEFAULT_TIMEOUT = 60000; // 60 seconds for PR operations
const MAX_OUTPUT_SIZE = 256 * 1024; // 256KB
const MAX_COMMITS_FOR_SUMMARY = 20; // Max commits to include in LLM summary
const MAX_DIFF_SIZE = 16 * 1024; // 16KB max diff for LLM context

// ============================================================================
// Types
// ============================================================================

/**
 * PR creation options
 */
export interface PRCreateOptions {
  /** PR title */
  title?: string;
  /** PR description/body */
  body?: string;
  /** Target branch (default: default branch) */
  base?: string;
  /** Source branch (default: current branch) */
  head?: string;
  /** Mark as draft PR */
  draft?: boolean;
  /** Reviewers to add (GitHub usernames) */
  reviewers?: string[];
  /** Team reviewers (GitHub team slugs) */
  teamReviewers?: string[];
  /** Labels to add */
  labels?: string[];
  /** Assignees */
  assignees?: string[];
  /** Milestone title or number */
  milestone?: string;
  /** Auto-generate title and body using LLM */
  autoGenerate?: boolean;
}

/**
 * PR creation result
 */
export interface PRCreateResult {
  /** PR number */
  number: number;
  /** PR URL */
  url: string;
  /** PR title */
  title: string;
  /** Target branch */
  base: string;
  /** Source branch */
  head: string;
  /** Whether PR is a draft */
  draft: boolean;
  /** State (open, closed, merged) */
  state: 'open' | 'closed' | 'merged';
  /** Reviewers added */
  reviewers?: string[];
  /** Labels added */
  labels?: string[];
}

/**
 * Commit info for PR generation
 */
export interface CommitInfo {
  sha: string;
  shortSha: string;
  message: string;
  author: string;
  date: string;
}

/**
 * PR summary generated by LLM
 */
export interface PRSummary {
  title: string;
  body: string;
  suggestedLabels: string[];
  changeType: 'feat' | 'fix' | 'docs' | 'refactor' | 'test' | 'chore';
}

/**
 * GitHub CLI auth status
 */
export interface GHAuthStatus {
  authenticated: boolean;
  username?: string;
  scopes?: string[];
  error?: string;
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Execute a command and return the result
 */
async function executeCommand(
  command: string,
  args: string[],
  cwd?: string
): Promise<{ success: boolean; stdout: string; stderr: string; exitCode: number }> {
  const workingDir = cwd ? path.resolve(cwd) : process.cwd();

  return new Promise((resolve) => {
    const spawnOptions: SpawnOptions = {
      cwd: workingDir,
      shell: os.platform() === 'win32',
      windowsHide: true,
    };

    const proc = spawn(command, args, spawnOptions);
    let stdout = '';
    let stderr = '';

    const timeout = setTimeout(() => {
      proc.kill('SIGTERM');
      resolve({
        success: false,
        stdout,
        stderr: 'Command timed out',
        exitCode: -1,
      });
    }, DEFAULT_TIMEOUT);

    proc.stdout?.on('data', (data: Buffer) => {
      if (stdout.length + data.length <= MAX_OUTPUT_SIZE) {
        stdout += data.toString();
      }
    });

    proc.stderr?.on('data', (data: Buffer) => {
      if (stderr.length + data.length <= MAX_OUTPUT_SIZE) {
        stderr += data.toString();
      }
    });

    proc.on('close', (exitCode) => {
      clearTimeout(timeout);
      resolve({
        success: exitCode === 0,
        stdout: stdout.trim(),
        stderr: stderr.trim(),
        exitCode: exitCode ?? -1,
      });
    });

    proc.on('error', (error) => {
      clearTimeout(timeout);
      resolve({
        success: false,
        stdout: '',
        stderr: error.message,
        exitCode: -1,
      });
    });
  });
}

/**
 * Execute a git command
 */
async function executeGitCommand(
  args: string[],
  cwd?: string
): Promise<{ success: boolean; stdout: string; stderr: string; exitCode: number }> {
  return executeCommand('git', args, cwd);
}

/**
 * Execute a GitHub CLI command
 */
async function executeGHCommand(
  args: string[],
  cwd?: string
): Promise<{ success: boolean; stdout: string; stderr: string; exitCode: number }> {
  return executeCommand('gh', args, cwd);
}

/**
 * Check if directory is a git repository
 */
async function isGitRepository(cwd?: string): Promise<boolean> {
  const result = await executeGitCommand(['rev-parse', '--is-inside-work-tree'], cwd);
  return result.success && result.stdout === 'true';
}

/**
 * Check GitHub CLI authentication status
 */
async function checkGHAuth(): Promise<GHAuthStatus> {
  const result = await executeGHCommand(['auth', 'status']);

  if (result.success) {
    // Parse auth status output
    const usernameMatch = result.stderr.match(/Logged in to [^ ]+ as ([^ ]+)/);
    const scopesMatch = result.stderr.match(/Token scopes: (.+)/);

    return {
      authenticated: true,
      username: usernameMatch?.[1],
      scopes: scopesMatch?.[1]?.split(', '),
    };
  }

  return {
    authenticated: false,
    error: result.stderr || 'Not authenticated with GitHub CLI',
  };
}

/**
 * Check if gh CLI is installed
 */
async function isGHInstalled(): Promise<boolean> {
  const result = await executeGHCommand(['--version']);
  return result.success;
}

/**
 * Get the default branch of the repository
 */
async function getDefaultBranch(cwd?: string): Promise<string> {
  // Try to get from remote HEAD
  const remoteResult = await executeGitCommand(
    ['symbolic-ref', 'refs/remotes/origin/HEAD'],
    cwd
  );

  if (remoteResult.success) {
    // Extract branch name from refs/remotes/origin/main
    const match = remoteResult.stdout.match(/refs\/remotes\/origin\/(.+)/);
    if (match) return match[1];
  }

  // Fallback: check common branch names
  for (const branch of ['main', 'master', 'develop']) {
    const checkResult = await executeGitCommand(
      ['show-ref', '--verify', '--quiet', `refs/remotes/origin/${branch}`],
      cwd
    );
    if (checkResult.success) return branch;
  }

  return 'main'; // Default fallback
}

/**
 * Get current branch name
 */
async function getCurrentBranch(cwd?: string): Promise<string> {
  const result = await executeGitCommand(['branch', '--show-current'], cwd);
  return result.success ? result.stdout : 'HEAD';
}

/**
 * Get commits between two branches
 */
async function getCommitsBetween(
  base: string,
  head: string,
  cwd?: string
): Promise<CommitInfo[]> {
  const result = await executeGitCommand(
    [
      'log',
      `${base}..${head}`,
      `--max-count=${MAX_COMMITS_FOR_SUMMARY}`,
      '--pretty=format:%H|%h|%s|%an|%ai',
    ],
    cwd
  );

  if (!result.success || !result.stdout) {
    return [];
  }

  return result.stdout.split('\n').map((line) => {
    const [sha, shortSha, message, author, date] = line.split('|');
    return { sha, shortSha, message, author, date };
  });
}

/**
 * Get diff stats between branches
 */
async function getDiffStats(
  base: string,
  head: string,
  cwd?: string
): Promise<{ files: number; insertions: number; deletions: number }> {
  const result = await executeGitCommand(
    ['diff', '--shortstat', `${base}...${head}`],
    cwd
  );

  if (!result.success || !result.stdout) {
    return { files: 0, insertions: 0, deletions: 0 };
  }

  const filesMatch = result.stdout.match(/(\d+) files? changed/);
  const insertMatch = result.stdout.match(/(\d+) insertions?/);
  const deleteMatch = result.stdout.match(/(\d+) deletions?/);

  return {
    files: filesMatch ? parseInt(filesMatch[1], 10) : 0,
    insertions: insertMatch ? parseInt(insertMatch[1], 10) : 0,
    deletions: deleteMatch ? parseInt(deleteMatch[1], 10) : 0,
  };
}

/**
 * Get truncated diff for LLM context
 */
async function getDiffForLLM(
  base: string,
  head: string,
  cwd?: string
): Promise<{ content: string; truncated: boolean }> {
  const result = await executeGitCommand(
    ['diff', `${base}...${head}`],
    cwd
  );

  if (!result.success) {
    return { content: '', truncated: false };
  }

  if (result.stdout.length > MAX_DIFF_SIZE) {
    return {
      content: result.stdout.slice(0, MAX_DIFF_SIZE) + '\n... [diff truncated]',
      truncated: true,
    };
  }

  return { content: result.stdout, truncated: false };
}

/**
 * Build LLM prompt for PR summary generation
 */
function buildPRSummaryPrompt(
  commits: CommitInfo[],
  diffStats: { files: number; insertions: number; deletions: number },
  diffContent: string,
  base: string,
  head: string
): string {
  const commitList = commits
    .map((c) => `- ${c.shortSha}: ${c.message} (${c.author})`)
    .join('\n');

  return `Analyze the following git changes and generate a pull request title and description.

## Branch Information
- Source branch: ${head}
- Target branch: ${base}
- Commits: ${commits.length}

## Commit History
${commitList}

## Change Statistics
- Files changed: ${diffStats.files}
- Insertions: ${diffStats.insertions}
- Deletions: ${diffStats.deletions}

## Diff Content
\`\`\`diff
${diffContent}
\`\`\`

## Instructions
Generate a pull request summary with:
1. **Title**: A concise, descriptive title (under 72 characters)
   - Use conventional commit format if appropriate: feat:, fix:, docs:, etc.
   - Focus on WHAT the PR does, not HOW

2. **Body**: A clear description including:
   - Summary of changes (2-3 sentences)
   - Key changes as bullet points
   - Any breaking changes or important notes

3. **Labels**: Suggest appropriate labels (e.g., feature, bug, documentation, refactor)

4. **Change Type**: Classify as: feat, fix, docs, refactor, test, or chore

Respond in the following JSON format ONLY (no markdown, no explanation):
{
  "title": "Your PR title here",
  "body": "Your PR description here\\n\\n## Changes\\n- Change 1\\n- Change 2",
  "suggestedLabels": ["label1", "label2"],
  "changeType": "feat"
}`;
}

/**
 * Generate PR summary using LLM
 */
async function generatePRSummary(
  commits: CommitInfo[],
  diffStats: { files: number; insertions: number; deletions: number },
  diffContent: string,
  base: string,
  head: string
): Promise<PRSummary> {
  try {
    const llmManager = getLLMManager();

    const systemPrompt = `You are a pull request summary generator. Your only job is to analyze git changes and produce clear, professional PR titles and descriptions. You respond with ONLY valid JSON - no explanations, no markdown formatting, no extra text.`;

    const context = createConversationContext(systemPrompt);
    const prompt = buildPRSummaryPrompt(commits, diffStats, diffContent, base, head);

    const response = await llmManager.chat(prompt, context);

    if (!response.content) {
      throw new Error('Empty LLM response');
    }

    // Parse JSON response
    const jsonMatch = response.content.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('Invalid JSON response from LLM');
    }

    const summary = JSON.parse(jsonMatch[0]) as PRSummary;

    // Validate required fields
    if (!summary.title || !summary.body) {
      throw new Error('Missing required fields in PR summary');
    }

    return summary;
  } catch (error) {
    logger.warn('LLM PR summary generation failed, using fallback', {
      error: (error as Error).message,
    });

    // Fallback: Generate from commits
    const firstCommit = commits[0];
    const commitTypes = commits.map((c) => {
      const match = c.message.match(/^(feat|fix|docs|refactor|test|chore)/i);
      return match ? match[1].toLowerCase() : 'chore';
    });
    const primaryType = commitTypes[0] || 'chore';

    return {
      title: firstCommit
        ? `${primaryType}: ${firstCommit.message.slice(0, 60)}`
        : `Merge ${head} into ${base}`,
      body: `## Summary\nThis PR includes ${commits.length} commit(s) from \`${head}\` to \`${base}\`.\n\n## Commits\n${commits.map((c) => `- ${c.shortSha}: ${c.message}`).join('\n')}\n\n## Stats\n- ${diffStats.files} files changed\n- +${diffStats.insertions} insertions\n- -${diffStats.deletions} deletions`,
      suggestedLabels: [primaryType],
      changeType: primaryType as PRSummary['changeType'],
    };
  }
}

/**
 * Parse PR URL from gh output
 */
function parsePRUrl(output: string): { number: number; url: string } | null {
  // gh pr create outputs the URL directly
  const urlMatch = output.match(
    /https:\/\/github\.com\/[^/]+\/[^/]+\/pull\/(\d+)/
  );

  if (urlMatch) {
    return {
      url: urlMatch[0],
      number: parseInt(urlMatch[1], 10),
    };
  }

  return null;
}

// ============================================================================
// US-016: Create Pull Request Tool
// ============================================================================

/**
 * Create a GitHub pull request
 */
export const gitPRCreateTool: AgentTool = {
  name: 'git_pr_create',
  description:
    'Create a GitHub pull request from the current branch. ' +
    'Voice commands: "Create pull request", "Open PR to main", "Create PR with title...". ' +
    'Auto-generates title and description using AI if not provided.',
  parameters: {
    type: 'object',
    properties: {
      title: {
        type: 'string',
        description: 'PR title. If not provided, auto-generated from commits.',
      },
      body: {
        type: 'string',
        description:
          'PR description. If not provided, auto-generated from commits and diff.',
      },
      base: {
        type: 'string',
        description: 'Target branch (default: repository default branch, usually main)',
      },
      head: {
        type: 'string',
        description: 'Source branch (default: current branch)',
      },
      draft: {
        type: 'boolean',
        description: 'Create as draft PR (default: false)',
      },
      reviewers: {
        type: 'array',
        description: 'GitHub usernames to request review from',
      },
      labels: {
        type: 'array',
        description: 'Labels to add to the PR',
      },
      assignees: {
        type: 'array',
        description: 'GitHub usernames to assign to the PR',
      },
      autoGenerate: {
        type: 'boolean',
        description: 'Auto-generate title and body using AI (default: true if not provided)',
      },
      path: {
        type: 'string',
        description: 'Repository directory path (default: current directory)',
      },
    },
    required: [],
  },
  execute: async (params: Record<string, unknown>): Promise<ActionResult> => {
    const cwd = params.path as string | undefined;
    const title = params.title as string | undefined;
    const body = params.body as string | undefined;
    const draft = params.draft === true;
    const reviewers = params.reviewers as string[] | undefined;
    const labels = params.labels as string[] | undefined;
    const assignees = params.assignees as string[] | undefined;
    const autoGenerate = params.autoGenerate !== false; // Default true

    try {
      // Validate git repository
      if (!(await isGitRepository(cwd))) {
        return {
          success: false,
          error: 'Not a git repository',
        };
      }

      // Check if gh is installed
      if (!(await isGHInstalled())) {
        return {
          success: false,
          error:
            'GitHub CLI (gh) is not installed. Please install it from https://cli.github.com/',
          metadata: {
            suggestion: 'Install GitHub CLI to create pull requests via voice',
          },
        };
      }

      // Check authentication
      const authStatus = await checkGHAuth();
      if (!authStatus.authenticated) {
        return {
          success: false,
          error: `Not authenticated with GitHub CLI. Run "gh auth login" to authenticate.`,
          metadata: {
            suggestion: 'Run "gh auth login" in your terminal to authenticate',
          },
        };
      }

      // Get branch info
      const base = (params.base as string) || (await getDefaultBranch(cwd));
      const head = (params.head as string) || (await getCurrentBranch(cwd));

      // Check if we're on the base branch
      if (head === base) {
        return {
          success: false,
          error: `Cannot create PR: you are on the target branch "${base}". Switch to a feature branch first.`,
          metadata: {
            suggestion: `Create a new branch with "git checkout -b feature-branch" first`,
          },
        };
      }

      // Check if there are commits to include
      const commits = await getCommitsBetween(base, head, cwd);
      if (commits.length === 0) {
        return {
          success: false,
          error: `No commits between "${base}" and "${head}". Make some commits first.`,
          metadata: {
            currentBranch: head,
            targetBranch: base,
          },
        };
      }

      // Generate title and body if needed
      let prTitle = title;
      let prBody = body;

      if (autoGenerate && (!prTitle || !prBody)) {
        logger.info('Auto-generating PR summary with LLM', {
          commits: commits.length,
          head,
          base,
        });

        const diffStats = await getDiffStats(base, head, cwd);
        const { content: diffContent } = await getDiffForLLM(base, head, cwd);
        const summary = await generatePRSummary(
          commits,
          diffStats,
          diffContent,
          base,
          head
        );

        prTitle = prTitle || summary.title;
        prBody = prBody || summary.body;

        // Add suggested labels if no labels provided
        if (!labels && summary.suggestedLabels.length > 0) {
          logger.debug('Using suggested labels', { labels: summary.suggestedLabels });
        }
      }

      // Fallback title if still empty
      if (!prTitle) {
        prTitle = commits[0]?.message || `Merge ${head} into ${base}`;
      }

      // Build gh pr create command
      const ghArgs = ['pr', 'create'];

      ghArgs.push('--title', prTitle);

      if (prBody) {
        ghArgs.push('--body', prBody);
      }

      ghArgs.push('--base', base);
      ghArgs.push('--head', head);

      if (draft) {
        ghArgs.push('--draft');
      }

      if (reviewers && reviewers.length > 0) {
        ghArgs.push('--reviewer', reviewers.join(','));
      }

      if (labels && labels.length > 0) {
        ghArgs.push('--label', labels.join(','));
      }

      if (assignees && assignees.length > 0) {
        ghArgs.push('--assignee', assignees.join(','));
      }

      logger.info('Creating pull request', {
        title: prTitle,
        base,
        head,
        draft,
        reviewers,
        labels,
      });

      // Execute gh pr create
      const result = await executeGHCommand(ghArgs, cwd);

      if (!result.success) {
        // Handle specific error cases
        if (result.stderr.includes('already exists')) {
          return {
            success: false,
            error: 'A pull request already exists for this branch.',
            metadata: {
              suggestion: 'Use git_pr_view to see the existing PR',
            },
          };
        }
        if (result.stderr.includes('no commits')) {
          return {
            success: false,
            error: 'No commits between the branches.',
          };
        }
        return {
          success: false,
          error: result.stderr || 'Failed to create pull request',
        };
      }

      // Parse the PR URL from output
      const prInfo = parsePRUrl(result.stdout);

      if (!prInfo) {
        logger.warn('Could not parse PR URL from output', { stdout: result.stdout });
      }

      const prResult: PRCreateResult = {
        number: prInfo?.number || 0,
        url: prInfo?.url || result.stdout,
        title: prTitle,
        base,
        head,
        draft,
        state: 'open',
        reviewers,
        labels,
      };

      logger.info('Pull request created', {
        number: prResult.number,
        url: prResult.url,
      });

      return {
        success: true,
        data: prResult,
        metadata: {
          message: `Pull request #${prResult.number} created successfully!`,
          voiceResponse: `I've created pull request number ${prResult.number}. ${draft ? "It's marked as a draft. " : ''}${reviewers?.length ? `I've requested review from ${reviewers.join(', ')}.` : ''} You can view it at the URL in the response.`,
        },
      };
    } catch (error) {
      logger.error('PR creation error', { error: (error as Error).message });
      return {
        success: false,
        error: `Failed to create pull request: ${(error as Error).message}`,
      };
    }
  },
};

// ============================================================================
// US-017: View/List Pull Requests Tool
// ============================================================================

/**
 * PR list item
 */
export interface PRListItem {
  number: number;
  title: string;
  state: string;
  author: string;
  url: string;
  draft: boolean;
  createdAt: string;
  headBranch: string;
  baseBranch: string;
}

/**
 * List or view pull requests
 */
export const gitPRListTool: AgentTool = {
  name: 'git_pr_list',
  description:
    'List pull requests for the repository or view a specific PR. ' +
    'Voice commands: "Show my pull requests", "List open PRs", "What PRs need review".',
  parameters: {
    type: 'object',
    properties: {
      state: {
        type: 'string',
        description: 'Filter by state: open, closed, merged, all (default: open)',
      },
      author: {
        type: 'string',
        description: 'Filter by author (GitHub username, or "@me" for yourself)',
      },
      limit: {
        type: 'number',
        description: 'Maximum number of PRs to list (default: 10)',
      },
      search: {
        type: 'string',
        description: 'Search query for PR titles',
      },
      path: {
        type: 'string',
        description: 'Repository directory path (default: current directory)',
      },
    },
    required: [],
  },
  execute: async (params: Record<string, unknown>): Promise<ActionResult> => {
    const cwd = params.path as string | undefined;
    const state = (params.state as string) || 'open';
    const author = params.author as string | undefined;
    const limit = (params.limit as number) || 10;
    const search = params.search as string | undefined;

    try {
      if (!(await isGitRepository(cwd))) {
        return { success: false, error: 'Not a git repository' };
      }

      if (!(await isGHInstalled())) {
        return {
          success: false,
          error: 'GitHub CLI (gh) is not installed',
        };
      }

      // Build gh pr list command
      const ghArgs = [
        'pr',
        'list',
        '--json',
        'number,title,state,author,url,isDraft,createdAt,headRefName,baseRefName',
        '--limit',
        String(limit),
      ];

      if (state !== 'all') {
        ghArgs.push('--state', state);
      }

      if (author) {
        ghArgs.push('--author', author);
      }

      if (search) {
        ghArgs.push('--search', search);
      }

      const result = await executeGHCommand(ghArgs, cwd);

      if (!result.success) {
        return {
          success: false,
          error: result.stderr || 'Failed to list pull requests',
        };
      }

      // Parse JSON output
      let prs: PRListItem[] = [];
      try {
        const rawPrs = JSON.parse(result.stdout) as Array<{
          number: number;
          title: string;
          state: string;
          author: { login: string };
          url: string;
          isDraft: boolean;
          createdAt: string;
          headRefName: string;
          baseRefName: string;
        }>;

        prs = rawPrs.map((pr) => ({
          number: pr.number,
          title: pr.title,
          state: pr.state,
          author: pr.author.login,
          url: pr.url,
          draft: pr.isDraft,
          createdAt: pr.createdAt,
          headBranch: pr.headRefName,
          baseBranch: pr.baseRefName,
        }));
      } catch (parseError) {
        logger.warn('Failed to parse PR list JSON', { error: (parseError as Error).message });
      }

      logger.debug('Pull requests listed', { count: prs.length, state });

      return {
        success: true,
        data: {
          prs,
          count: prs.length,
          state,
          author,
        },
        metadata: {
          voiceResponse:
            prs.length === 0
              ? `No ${state} pull requests found.`
              : `Found ${prs.length} ${state} pull request${prs.length === 1 ? '' : 's'}. ${prs.slice(0, 3).map((p) => `Number ${p.number}: ${p.title}`).join('. ')}`,
        },
      };
    } catch (error) {
      logger.error('PR list error', { error: (error as Error).message });
      return {
        success: false,
        error: `Failed to list pull requests: ${(error as Error).message}`,
      };
    }
  },
};

// ============================================================================
// US-018: View PR Details Tool
// ============================================================================

/**
 * PR detailed info
 */
export interface PRDetails {
  number: number;
  title: string;
  body: string;
  state: string;
  author: string;
  url: string;
  draft: boolean;
  createdAt: string;
  updatedAt: string;
  headBranch: string;
  baseBranch: string;
  additions: number;
  deletions: number;
  changedFiles: number;
  reviewers: string[];
  labels: string[];
  assignees: string[];
  mergeable: boolean;
  checksStatus: string;
}

/**
 * View details of a specific pull request
 */
export const gitPRViewTool: AgentTool = {
  name: 'git_pr_view',
  description:
    'View details of a specific pull request by number or the PR for the current branch. ' +
    'Voice commands: "Show PR 42", "What is the status of my PR", "View current PR".',
  parameters: {
    type: 'object',
    properties: {
      number: {
        type: 'number',
        description: 'PR number to view. If not provided, shows PR for current branch.',
      },
      path: {
        type: 'string',
        description: 'Repository directory path (default: current directory)',
      },
    },
    required: [],
  },
  execute: async (params: Record<string, unknown>): Promise<ActionResult> => {
    const cwd = params.path as string | undefined;
    const prNumber = params.number as number | undefined;

    try {
      if (!(await isGitRepository(cwd))) {
        return { success: false, error: 'Not a git repository' };
      }

      if (!(await isGHInstalled())) {
        return {
          success: false,
          error: 'GitHub CLI (gh) is not installed',
        };
      }

      // Build gh pr view command
      const ghArgs = [
        'pr',
        'view',
        '--json',
        'number,title,body,state,author,url,isDraft,createdAt,updatedAt,headRefName,baseRefName,additions,deletions,changedFiles,reviewRequests,labels,assignees,mergeable,statusCheckRollup',
      ];

      if (prNumber !== undefined) {
        ghArgs.push(String(prNumber));
      }

      const result = await executeGHCommand(ghArgs, cwd);

      if (!result.success) {
        if (result.stderr.includes('no pull requests found')) {
          return {
            success: false,
            error: prNumber
              ? `Pull request #${prNumber} not found`
              : 'No pull request found for the current branch',
          };
        }
        return {
          success: false,
          error: result.stderr || 'Failed to view pull request',
        };
      }

      // Parse JSON output
      let pr: PRDetails;
      try {
        const rawPr = JSON.parse(result.stdout) as {
          number: number;
          title: string;
          body: string;
          state: string;
          author: { login: string };
          url: string;
          isDraft: boolean;
          createdAt: string;
          updatedAt: string;
          headRefName: string;
          baseRefName: string;
          additions: number;
          deletions: number;
          changedFiles: number;
          reviewRequests: Array<{ login?: string; name?: string }>;
          labels: Array<{ name: string }>;
          assignees: Array<{ login: string }>;
          mergeable: string;
          statusCheckRollup: Array<{ conclusion: string }> | null;
        };

        // Determine checks status
        let checksStatus = 'unknown';
        if (rawPr.statusCheckRollup) {
          const allPassing = rawPr.statusCheckRollup.every(
            (c) => c.conclusion === 'SUCCESS' || c.conclusion === 'NEUTRAL'
          );
          const anyFailing = rawPr.statusCheckRollup.some(
            (c) => c.conclusion === 'FAILURE'
          );
          checksStatus = anyFailing ? 'failing' : allPassing ? 'passing' : 'pending';
        }

        pr = {
          number: rawPr.number,
          title: rawPr.title,
          body: rawPr.body || '',
          state: rawPr.state,
          author: rawPr.author.login,
          url: rawPr.url,
          draft: rawPr.isDraft,
          createdAt: rawPr.createdAt,
          updatedAt: rawPr.updatedAt,
          headBranch: rawPr.headRefName,
          baseBranch: rawPr.baseRefName,
          additions: rawPr.additions,
          deletions: rawPr.deletions,
          changedFiles: rawPr.changedFiles,
          reviewers: rawPr.reviewRequests.map((r) => r.login || r.name || ''),
          labels: rawPr.labels.map((l) => l.name),
          assignees: rawPr.assignees.map((a) => a.login),
          mergeable: rawPr.mergeable === 'MERGEABLE',
          checksStatus,
        };
      } catch (parseError) {
        logger.error('Failed to parse PR view JSON', {
          error: (parseError as Error).message,
        });
        return {
          success: false,
          error: 'Failed to parse pull request details',
        };
      }

      logger.debug('Pull request viewed', { number: pr.number });

      return {
        success: true,
        data: pr,
        metadata: {
          voiceResponse: `Pull request number ${pr.number}: "${pr.title}". ${pr.draft ? "It's a draft. " : ''}Status is ${pr.state}. ${pr.changedFiles} files changed with ${pr.additions} additions and ${pr.deletions} deletions. ${pr.mergeable ? 'It is mergeable.' : 'There may be conflicts.'}`,
        },
      };
    } catch (error) {
      logger.error('PR view error', { error: (error as Error).message });
      return {
        success: false,
        error: `Failed to view pull request: ${(error as Error).message}`,
      };
    }
  },
};

// ============================================================================
// US-019: Update Pull Request Tool
// ============================================================================

/**
 * Update an existing pull request
 */
export const gitPRUpdateTool: AgentTool = {
  name: 'git_pr_update',
  description:
    'Update an existing pull request (add reviewers, labels, update title/body). ' +
    'Voice commands: "Add reviewer to PR", "Add label to my PR", "Update PR title".',
  parameters: {
    type: 'object',
    properties: {
      number: {
        type: 'number',
        description: 'PR number to update. If not provided, updates PR for current branch.',
      },
      title: {
        type: 'string',
        description: 'New title for the PR',
      },
      body: {
        type: 'string',
        description: 'New body/description for the PR',
      },
      addReviewers: {
        type: 'array',
        description: 'Reviewers to add (GitHub usernames)',
      },
      addLabels: {
        type: 'array',
        description: 'Labels to add',
      },
      removeLabels: {
        type: 'array',
        description: 'Labels to remove',
      },
      addAssignees: {
        type: 'array',
        description: 'Assignees to add (GitHub usernames)',
      },
      removeAssignees: {
        type: 'array',
        description: 'Assignees to remove (GitHub usernames)',
      },
      ready: {
        type: 'boolean',
        description: 'Mark draft PR as ready for review',
      },
      path: {
        type: 'string',
        description: 'Repository directory path (default: current directory)',
      },
    },
    required: [],
  },
  execute: async (params: Record<string, unknown>): Promise<ActionResult> => {
    const cwd = params.path as string | undefined;
    const prNumber = params.number as number | undefined;
    const title = params.title as string | undefined;
    const body = params.body as string | undefined;
    const addReviewers = params.addReviewers as string[] | undefined;
    const addLabels = params.addLabels as string[] | undefined;
    const removeLabels = params.removeLabels as string[] | undefined;
    const addAssignees = params.addAssignees as string[] | undefined;
    const removeAssignees = params.removeAssignees as string[] | undefined;
    const ready = params.ready as boolean | undefined;

    try {
      if (!(await isGitRepository(cwd))) {
        return { success: false, error: 'Not a git repository' };
      }

      if (!(await isGHInstalled())) {
        return {
          success: false,
          error: 'GitHub CLI (gh) is not installed',
        };
      }

      const updates: string[] = [];

      // Update title/body with gh pr edit
      if (title || body) {
        const editArgs = ['pr', 'edit'];
        if (prNumber !== undefined) {
          editArgs.push(String(prNumber));
        }
        if (title) {
          editArgs.push('--title', title);
        }
        if (body) {
          editArgs.push('--body', body);
        }

        const editResult = await executeGHCommand(editArgs, cwd);
        if (!editResult.success) {
          return {
            success: false,
            error: editResult.stderr || 'Failed to update PR title/body',
          };
        }
        if (title) updates.push('title');
        if (body) updates.push('description');
      }

      // Add reviewers
      if (addReviewers && addReviewers.length > 0) {
        const reviewArgs = ['pr', 'edit'];
        if (prNumber !== undefined) {
          reviewArgs.push(String(prNumber));
        }
        reviewArgs.push('--add-reviewer', addReviewers.join(','));

        const reviewResult = await executeGHCommand(reviewArgs, cwd);
        if (reviewResult.success) {
          updates.push(`reviewers (${addReviewers.join(', ')})`);
        } else {
          logger.warn('Failed to add reviewers', { error: reviewResult.stderr });
        }
      }

      // Add labels
      if (addLabels && addLabels.length > 0) {
        const labelArgs = ['pr', 'edit'];
        if (prNumber !== undefined) {
          labelArgs.push(String(prNumber));
        }
        labelArgs.push('--add-label', addLabels.join(','));

        const labelResult = await executeGHCommand(labelArgs, cwd);
        if (labelResult.success) {
          updates.push(`labels (${addLabels.join(', ')})`);
        } else {
          logger.warn('Failed to add labels', { error: labelResult.stderr });
        }
      }

      // Remove labels
      if (removeLabels && removeLabels.length > 0) {
        const unlabelArgs = ['pr', 'edit'];
        if (prNumber !== undefined) {
          unlabelArgs.push(String(prNumber));
        }
        unlabelArgs.push('--remove-label', removeLabels.join(','));

        const unlabelResult = await executeGHCommand(unlabelArgs, cwd);
        if (unlabelResult.success) {
          updates.push(`removed labels (${removeLabels.join(', ')})`);
        }
      }

      // Add assignees
      if (addAssignees && addAssignees.length > 0) {
        const assignArgs = ['pr', 'edit'];
        if (prNumber !== undefined) {
          assignArgs.push(String(prNumber));
        }
        assignArgs.push('--add-assignee', addAssignees.join(','));

        const assignResult = await executeGHCommand(assignArgs, cwd);
        if (assignResult.success) {
          updates.push(`assignees (${addAssignees.join(', ')})`);
        }
      }

      // Remove assignees
      if (removeAssignees && removeAssignees.length > 0) {
        const unassignArgs = ['pr', 'edit'];
        if (prNumber !== undefined) {
          unassignArgs.push(String(prNumber));
        }
        unassignArgs.push('--remove-assignee', removeAssignees.join(','));

        const unassignResult = await executeGHCommand(unassignArgs, cwd);
        if (unassignResult.success) {
          updates.push(`removed assignees (${removeAssignees.join(', ')})`);
        }
      }

      // Mark as ready for review
      if (ready === true) {
        const readyArgs = ['pr', 'ready'];
        if (prNumber !== undefined) {
          readyArgs.push(String(prNumber));
        }

        const readyResult = await executeGHCommand(readyArgs, cwd);
        if (readyResult.success) {
          updates.push('marked ready for review');
        } else {
          logger.warn('Failed to mark PR ready', { error: readyResult.stderr });
        }
      }

      if (updates.length === 0) {
        return {
          success: true,
          data: { updated: false, message: 'No updates specified' },
        };
      }

      logger.info('Pull request updated', { prNumber, updates });

      return {
        success: true,
        data: {
          updated: true,
          prNumber,
          changes: updates,
        },
        metadata: {
          voiceResponse: `Updated the pull request. Changed: ${updates.join(', ')}.`,
        },
      };
    } catch (error) {
      logger.error('PR update error', { error: (error as Error).message });
      return {
        success: false,
        error: `Failed to update pull request: ${(error as Error).message}`,
      };
    }
  },
};

// ============================================================================
// US-020: Check PR Status Tool
// ============================================================================

/**
 * Check PR status and CI checks
 */
export const gitPRChecksTool: AgentTool = {
  name: 'git_pr_checks',
  description:
    'Check the status of CI checks on a pull request. ' +
    'Voice commands: "Check PR status", "Are the tests passing", "What is the CI status".',
  parameters: {
    type: 'object',
    properties: {
      number: {
        type: 'number',
        description: 'PR number. If not provided, checks PR for current branch.',
      },
      watch: {
        type: 'boolean',
        description: 'Wait for checks to complete (default: false)',
      },
      path: {
        type: 'string',
        description: 'Repository directory path (default: current directory)',
      },
    },
    required: [],
  },
  execute: async (params: Record<string, unknown>): Promise<ActionResult> => {
    const cwd = params.path as string | undefined;
    const prNumber = params.number as number | undefined;
    const watch = params.watch === true;

    try {
      if (!(await isGitRepository(cwd))) {
        return { success: false, error: 'Not a git repository' };
      }

      if (!(await isGHInstalled())) {
        return {
          success: false,
          error: 'GitHub CLI (gh) is not installed',
        };
      }

      // Build gh pr checks command
      const ghArgs = ['pr', 'checks'];
      if (prNumber !== undefined) {
        ghArgs.push(String(prNumber));
      }
      if (watch) {
        ghArgs.push('--watch');
      }

      const result = await executeGHCommand(ghArgs, cwd);

      // gh pr checks returns non-zero if checks are failing, but we still want the output
      const lines = result.stdout.split('\n').filter((l) => l.trim());

      // Parse check results
      const checks = lines.map((line) => {
        const parts = line.split('\t');
        return {
          name: parts[0]?.trim() || 'Unknown',
          status: parts[1]?.trim() || 'unknown',
          conclusion: parts[2]?.trim() || '',
          url: parts[3]?.trim() || '',
        };
      });

      const passing = checks.filter((c) =>
        ['pass', 'success', 'neutral'].includes(c.status.toLowerCase())
      );
      const failing = checks.filter((c) =>
        ['fail', 'failure'].includes(c.status.toLowerCase())
      );
      const pending = checks.filter((c) =>
        ['pending', 'in_progress', 'queued'].includes(c.status.toLowerCase())
      );

      const overallStatus =
        failing.length > 0 ? 'failing' : pending.length > 0 ? 'pending' : 'passing';

      logger.debug('PR checks status', {
        prNumber,
        total: checks.length,
        passing: passing.length,
        failing: failing.length,
        pending: pending.length,
      });

      return {
        success: true,
        data: {
          prNumber,
          overallStatus,
          checks,
          summary: {
            total: checks.length,
            passing: passing.length,
            failing: failing.length,
            pending: pending.length,
          },
        },
        metadata: {
          voiceResponse:
            checks.length === 0
              ? 'No checks configured for this pull request.'
              : overallStatus === 'passing'
                ? `All ${checks.length} checks are passing.`
                : overallStatus === 'failing'
                  ? `${failing.length} of ${checks.length} checks are failing: ${failing.map((c) => c.name).join(', ')}.`
                  : `${pending.length} checks are still running. ${passing.length} passing, ${failing.length} failing so far.`,
        },
      };
    } catch (error) {
      logger.error('PR checks error', { error: (error as Error).message });
      return {
        success: false,
        error: `Failed to check PR status: ${(error as Error).message}`,
      };
    }
  },
};

// ============================================================================
// Tool Registry
// ============================================================================

/**
 * Get all git PR tools
 */
export function getGitPRTools(): AgentTool[] {
  return [
    gitPRCreateTool,
    gitPRListTool,
    gitPRViewTool,
    gitPRUpdateTool,
    gitPRChecksTool,
  ];
}

export default {
  gitPRCreateTool,
  gitPRListTool,
  gitPRViewTool,
  gitPRUpdateTool,
  gitPRChecksTool,
  getGitPRTools,
};
